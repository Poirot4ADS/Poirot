if (result_fault_injection_)
{
  auto mutable_pose = localization.mutable_pose();
  if (orientation_offset_ != 0.0)
  {
    double ori_x = mutable_pose->orientation().qx() + orientation_offset_;
    double ori_y = mutable_pose->orientation().qy() + orientation_offset_;
    double ori_z = mutable_pose->orientation().qz() + orientation_offset_;
    double ori_w = mutable_pose->orientation().qw() + orientation_offset_;
    double norm = std::sqrt(ori_x * ori_x + ori_y * ori_y + ori_z * ori_z + ori_w * ori_w);
    mutable_pose->mutable_orientation()->set_qx(ori_x / norm);
    mutable_pose->mutable_orientation()->set_qy(ori_y / norm);
    mutable_pose->mutable_orientation()->set_qz(ori_z / norm);
    mutable_pose->mutable_orientation()->set_qw(ori_w / norm);
    double heading = common::math::QuaternionToHeading(
        mutable_pose.orientation().qw(), mutable_pose.orientation().qx(),
        mutable_pose.orientation().qy(), mutable_pose.orientation().qz());
    mutable_pose->set_heading(heading);
  }
  if (position_offset_ != 0.0)
  {
    double heading = mutable_pose->heading();
    mutable_pose->mutable_position()->set_x(mutable_pose->position().x() + position_offset_ *std::cos(heading));
    mutable_pose->mutable_position()->set_y(mutable_pose->position().y() + position_offset_ *std::sin(heading));
  }
  if (linear_velocity_offset_ != 0.0)
  {
    double heading = mutable_pose->heading();
    mutable_pose->mutable_linear_velocity()->set_x(mutable_pose->linear_velocity().x() +linear_velocity_offset_ * std::cos(heading));
    mutable_pose->mutable_linear_velocity()->set_y(mutable_pose->linear_velocity().y() +linear_velocity_offset_ * std::sin(heading));
  }
  if (linear_acceleration_offset_ != 0.0)
  {
    double heading = mutable_pose->heading();
    mutable_pose->mutable_linear_acceleration()->set_x(mutable_pose->linear_acceleration().x()+ linear_acceleration_offset_ * std::cos(heading));
    mutable_pose->mutable_linear_acceleration()->set_y(mutable_pose->linear_acceleration().y()+ linear_acceleration_offset_ * std::sin(heading));
  }
  if (angular_velocity_offset_ != 0.0)
  {
    double heading = mutable_pose->heading();
    mutable_pose->mutable_angular_velocity()->set_x(mutable_pose->angular_velocity().x() +angular_velocity_offset_ * std::cos(heading));
    mutable_pose->mutable_angular_velocity()->set_y(mutable_pose->angular_velocity().y() +angular_velocity_offset_ * std::sin(heading));
  }
  if (euler_angles_offset_ != 0.0)
  {
    double heading = mutable_pose->euler_angles() + euler_angles_offset_;
    heading = std::max(0.0, heading);
    heading = std::min(heading, 6.283185);
    mutable_pose->mutable_euler_angles()->set_z(heading)
  }
}
Add the above code to the 'Proc' function and include the 'position_offset' field in the 'conf'.

Perturbations in the localization module are mainly divided into GPS and IMU components. The perturbed fields include 'position', 'orientation', 'linear_velocity', 'linear_acceleration', 'angular_velocity', and 'euler_angles'. Each field can be perturbed individually. The 'heading' variable is directly derived from 'orientation', so it is not treated as a separate perturbation.
